import java.util.*; 
public class FibonacciHeap<Node2> {
    
    public static final class Entry<Node2> {
    	//All the fields of Fibonacci heap is created here
        int degree = 0;       
        boolean isMarked = false; 
        Entry<Node2> next;   
        Entry<Node2> prev;
        Entry<Node2> parent; 
        Entry<Node2>  child;  
        Node2 elem;     
        int priority; 
        public Node2 getValue() {
            return elem;
        }
        
        public void setValue(Node2 value) {
            elem = value;
        }

        public void setPriority(int priority) {
        	this.priority = priority;
        }
        public int getPriority() {
            return priority;
        }
         
        private Entry(Node2 elem, int priority) {
            next = prev = this;
            this.elem = elem;
            this.priority = priority;
        }
    }

    private Entry<Node2>  min = null;
    private int size = 0;
    //The elements are inserted into the heap in the below method
    public Entry<Node2> makeHeap(Node2 value, int priority) {
    	validatePriority(priority);
        Entry<Node2>  result = new Entry<Node2> (value, priority);

        // Merge this single list with the tree list. 
        min = unionLists(min, result); 
        ++size;
        return result;
    }

    //Returns Min element.
    public Entry<Node2>  min() {
        if (isEmpty())
        {
            System.out.println("Heap is empty.");
            System.exit(0);
        }
        return min;
    }

     // Returns whether the heap is empty.
    public boolean isEmpty() {
        return min == null;
    }

    public int size() {
        return size;
    }
     // Removes and returns the minimum element of the Fibonacci heap.
    public Entry<Node2>  removeMin() {
        if (isEmpty())
            System.out.println("Heap is empty.");
        --size;
        Entry<Node2>  minElem = min;
        if (min.next == min) { 
            min = null;
        }
        else { 
            min.prev.next = min.next;
            min.next.prev = min.prev;
            min = min.next; // Arbitrary element of the root list.
        }
        if (minElem.child != null) {
            // Keep track of the first visited node.
        	Entry<?> current = minElem.child;
            do {
                current.parent = null;
                current = current.next;
            } while (current != minElem.child);
        }
        min = unionLists(min, minElem.child);
        if (min == null) return minElem;

        // Next, we need to combine all of the roots of same degree
        List<Entry<Node2>> treeTable = new ArrayList<Entry<Node2>>();

         // Adding all of the nodes to a list then will visit each element of this list in order.
         
        List<Entry<Node2>> nodeList = new ArrayList<Entry<Node2>>();
        for (Entry<Node2>  current = min; nodeList.isEmpty() || nodeList.get(0) != current; current = current.next)
        	nodeList.add(current);

        // Traverse this list and perform the appropriate union steps.
        for (Entry<Node2>  current: nodeList) { 
            while (true) {
                while (current.degree >= treeTable.size())
                    treeTable.add(null);
                
                if (treeTable.get(current.degree) == null) {
                    treeTable.set(current.degree, current);
                    break;
                } 
                Entry<Node2>  other = treeTable.get(current.degree);
                treeTable.set(current.degree, null); 
                Entry<Node2>  min = (other.priority < current.priority)? other : current;
                Entry<Node2>  max = (other.priority < current.priority)? current  : other;
                max.next.prev = max.prev;
                max.prev.next = max.next;

                // Make it single to merge it.
                max.next = max.prev = max;
                min.child = unionLists(min.child, max); 
                max.parent = min;
                max.isMarked = false;
                ++min.degree; 
                current = min;
            }
            
            if (current.priority <= min.priority) 
            	min = current;
        }
        return minElem;
    }

     // Decreases the key of the specified element to the new priority.
    public void decreaseKey(Entry<Node2>  entry, int newPriority) {
    	validatePriority(newPriority);
        if (newPriority > entry.priority)
        {
            System.out.println("New priority exceeds old.");
        	System.exit(0);
        }
        //In this function the ordering is done
        decreaseKeyCascade(entry, newPriority);
    }
    
     // Deletes this Entry from the Fibonacci heap that contains it
    public void delete(Entry<Node2>  entry) {  
        decreaseKeyCascade(entry, -9999);
        removeMin();
    }

    //Checks the priority
    private void validatePriority(int priority) {
        if (priority != (int)priority)
        {
        	System.out.println(priority + " is invalid.");
        	System.exit(0);
        }
    }

    //Merge the two lists
    private static <Node2>  Entry<Node2>  unionLists(Entry<Node2>  one, Entry<Node2>  two) {
        if (one == null && two == null) { 
            return null;
        }
        else if (one != null && two == null) { 
            return one;
        }
        else if (one == null && two != null) { 
            return two;
        }
        else { 
        	Entry<Node2>  oneNext1 = one.next; 
            one.next = two.next;
            one.next.prev = one;
            two.next = oneNext1;
            two.next.prev = two;

            // Return a pointer to whichever's smaller. 
            if(one.priority < two.priority)
            	return one; 
            else
            	return two;
        }
    }
    // Merge two heaps
    public static <Node2> FibonacciHeap<Node2>  merge(FibonacciHeap<Node2>  heap1, FibonacciHeap<Node2>  heap2) {
        // Create a new FibHeap to hold the result.
    	FibonacciHeap<Node2>  result = new FibonacciHeap<Node2> ();
        result.min = unionLists(heap1.min, heap2.min);
        result.size = heap1.size + heap2.size;
        heap1.size = heap2.size = 0;
        heap1.min  = null;
        heap2.min  = null;
        return result;
    }
     // Decreases the key of a node in the graph   
    private void decreaseKeyCascade(Entry<Node2>  entry, int priority) { 
        entry.priority = priority;

        // If the node no longer has a higher priority than its parent, cut it.
        if (entry.parent != null && entry.priority <= entry.parent.priority)
            cutNode(entry);  
        if (entry.priority <= min.priority)
            min = entry;
    }

     // Cuts a node from its parent.  If the parent was already marked, recursively
     // cuts that node from its parent as well.
    
    private void cutNode(Entry<Node2>  entry) {
        entry.isMarked = false; 
        if (entry.parent == null) return;

        // Join the node's siblings 
        if (entry.next != entry) {
            entry.next.prev = entry.prev;
            entry.prev.next = entry.next;
        }

        if (entry.parent.child == entry) {
            if (entry.next != entry) {
                entry.parent.child = entry.next;
            }
            else {
                entry.parent.child = null;
            }
        }

        --entry.parent.degree;
        entry.prev = entry.next = entry;
        min = unionLists(min, entry);
        if (entry.parent.isMarked)
            cutNode(entry.parent);
        else
            entry.parent.isMarked = true;
        entry.parent = null;
    }
}
